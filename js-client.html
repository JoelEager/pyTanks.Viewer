<!DOCTYPE html>
<html>
    <head>
        <title>pyTanks Viewer</title>
        <style>
            td {
                padding: 3px;
            }
            
            tr:hover:not(.header) {
                color: cadetblue;
            }
        </style>
    </head>
    <body>
        <h2 style="margin: 0px;">pyTanks Viewer</h2>
        <p style="margin-top: 5px;">For more information on pyTanks <a href="https://github.com/JoelEager/pyTanks.Viewer" target="_blank">click here</a>.</p>
        <div style="text-align: center;">
            <p id="clientStatus">Connecting...</p>
            <canvas id="canvas" width="500" height="500" style="display: inline-block; border: 1px solid #d3d3d3; vertical-align: top; margin-bottom: 10px;"></canvas>
            <div style="display: inline-block; border: 1px solid #d3d3d3;">
                <table id="scoreboard" style="text-align: left;">
                    <tr class="header"><td></td><td>Tank</td><td>Kills this round</td><td>Rounds won</td></tr>
                </table>
                <div style="margin: 5px;">
                    A = alive, D = dead. <br />
                    Hover over a tank above to see it highlighted on the map.
                </div>
            </div>
        </div>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script>
            // Client configuration - must match server's settings
            var config = {
                framesPerSecond: 60,            // FPS to run the simulation at
                mapSize: {                      // Size of the map (must be the same as the canvas size)
                    x: 500,
                    y: 500
                },
                tankSpeed: 30,                  // Tank speed in pixels per second
                shellSpeed: 150,                // Shell speed in pixels per second
                maxPlayers: 15,                 // Maximum number of connected players
                serverIP: "localhost",          // Server's IP
                serverPort: "9042",             // Server's port
                apiPath: "/pyTanksAPI/viewer",  // API path on the server to connect to
                logFPS: true                    // Enable or disable client side FPS logging
            };
            
            // Colors used for rendering the canvas
            var colors = {
                selectedTank: "cadetblue",
                deadTank: "orange",
                aliveTank: "black",
                shell: "red",
                wall: "gray"
            }
            
            // Globals
            var gameState = null;
            var gameStateUpdate = null;
            var canvas = null;
            var clientStatus = null;
            var scoreboardRows = [];
            var selectedTank = -1;
            var framesDrawn = 0;
            
            // Setup and run the viewer
            $(function() {
                canvas = $("#canvas")[0].getContext("2d");
                clientStatus = $("#clientStatus");
                
                // Setup the scoreboard
                var scoreboard = $("#scoreboard");
                for (var count = 0; count < config.maxPlayers; count++) {
                    var aRow = $(
                        "<tr id='score-" + count + "' " +
                        "onmouseenter='selectedTank = " + count + ";' onmouseleave='selectedTank = -1;'>" + 
                        "<td>&nbsp;</td></tr>");
                    
                    scoreboard.append(aRow);
                    scoreboardRows.push(aRow);
                }
                
                // Connect to sever
                var socket = new WebSocket("ws://" + config.serverIP + ":" + config.serverPort + config.apiPath);
                
                // Finish setup on successful connect
                socket.onopen = function (event) {
                    clientStatus.html("Connected");
                    
                    // Start the doTick clock
                    var ticker = window.setInterval(function(){ doTick(); }, 1000 / config.framesPerSecond);
                    
                    if (config.logFPS) {
                        window.setInterval(function() {
                            console.log(framesDrawn);
                            framesDrawn = 0;
                        }, 1000);
                    }
                
                    // Store any incoming gameState updates
                    socket.onmessage = function (event) {
                        gameStateUpdate = JSON.parse(event.data);
                    };
                    
                    // Handle a disconnect
                    socket.onclose = function (event) {
                        window.clearInterval(ticker);
                        clientStatus.html("Lost connection");
                    };
                };
            
                // Handle errors in connecting
                socket.onerror = function (event) {
                    clientStatus.html("Failed to connect");
                };
            });
            
            // Calculates and renders one frame
            function doTick() {
                // Return if no data from the server has arrived yet
                if (gameState == null && gameStateUpdate == null) {
                    return;
                }
                
                if (gameStateUpdate == null) {
                    // Extrapolate if there isn't an update from the server
                    var totalDistance = config.tankSpeed * (1 / config.framesPerSecond);
                    for (tank of gameState.tanks) {
                        if (tank.moving) {
                            tank.x += Math.cos(tank.heading) * totalDistance;
                            tank.y -= Math.sin(tank.heading) * totalDistance;
                        }
                    }
                    
                    totalDistance = config.shellSpeed * (1 / config.framesPerSecond);
                    for (shell of gameState.shells) {
                        shell.x += Math.cos(shell.heading) * totalDistance;
                        shell.y -= Math.sin(shell.heading) * totalDistance;
                    }
                } else {
                    // Apply the update from the server
                    gameState = gameStateUpdate;
                    gameStateUpdate = null;
                    
                    // Sort the tanks
                    gameState.tanks.sort(function(tank1, tank2) {
                        // lower = first on the list
                        var weight1 = -1 * tank1.kills;
                        var weight2 = -1 * tank2.kills;
                        
                        if (tank1.alive) {
                            weight1 -= 100;
                        }
                        if (tank2.alive) {
                            weight2 -= 100;
                        }
                        
                        return weight1 - weight2;
                    });
                    
                    // Update the status
                    if (gameState.ongoingGame) {
                        clientStatus.html("Connected - Game in progress");
                    } else {
                        clientStatus.html("Connected - Waiting for players. (Feel free to connect a couple more to get a game started.)");
                    }
                    
                    // Update any out of date scoreboard entries
                    for (var count = 0; count < config.maxPlayers; count++) {
                        var scoreHTML = "";
                        
                        if (count < gameState.tanks.length) {
                            var tank = gameState.tanks[count];
                            scoreHTML += "<td>";
                            
                            if (tank.alive) {
                                scoreHTML += "A";
                            } else {
                                scoreHTML += "D";
                            }
                            
                            scoreHTML += "</td><td>" + tank.name + "</td><td>" + tank.kills + "</td><td>" + tank.wins + "</td>";
                        } else {
                            scoreHTML = "<td>&nbsp;</td>";
                        }
                        
                        if (scoreboardRows[count].html() != scoreHTML) {
                            scoreboardRows[count].html(scoreHTML);
                        }
                    }
                }
                
                // Render based on that game state
                canvas.clearRect(0, 0, config.mapSize.x, config.mapSize.y);
                
                if (gameState.ongoingGame) {
                    for (var count = 0; count < gameState.tanks.length; count++) {
                        var tank = gameState.tanks[count];
                        
                        if (!tank.alive) {
                            if (count == selectedTank) {
                                canvas.fillStyle = colors.selectedTank;
                            } else {
                                canvas.fillStyle = colors.deadTank;
                            }
                            
                            drawRotatedRect(tank.x - 5, tank.y - 5, 10, 10, tank.heading);
                        }
                    }
                    
                    canvas.fillStyle = colors.shell;
                    for (shell of gameState.shells) {
                        drawRotatedRect(shell.x - 1, shell.y - 1, 3, 3, shell.heading);
                    }
                    
                    for (var count = 0; count < gameState.tanks.length; count++) {
                        var tank = gameState.tanks[count];
                        
                        if (tank.alive) {
                            if (count == selectedTank) {
                                canvas.fillStyle = colors.selectedTank;
                            } else {
                                canvas.fillStyle = colors.aliveTank;
                            }
                        
                            drawRotatedRect(tank.x - 5, tank.y - 5, 10, 10, tank.heading);
                        }
                    }
                    
                    canvas.fillStyle = colors.wall;
                    for (wall of gameState.walls) {
                        canvas.fillRect(wall.x - wall.width / 2, wall.y - wall.height / 2, wall.width, wall.height);
                    }
                }
                
                if (config.logFPS) {
                    framesDrawn += 1;
                }
            }
            
            // Draws a rotated rectangle with the current fill style
            function drawRotatedRect(x, y, width, height, heading) {
                canvas.save();
                canvas.translate(x + width / 2, y + height / 2);
                canvas.rotate(heading);
                // Note: after transforming [0,0] is visually [x,y] so the rect needs to be offset accordingly when drawn
                canvas.fillRect(-width / 2, -height / 2, width, height);
                canvas.restore();
            }
        </script>
    </body>
</html>