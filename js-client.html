<!DOCTYPE html>
<html>
    <head>
        <title>pyTanks Viewer</title>
        <style>
            td {
                padding: 3px;
            }
        </style>
    </head>
    <body>
        <center>
            <p><small id="clientStatus">Connecting...</small></p>
            <canvas id="canvas" width="500" height="500" style="border: 1px solid #d3d3d3;"></canvas>
            <table id="scoreboard" style="margin-left: 25px; border: 1px solid #d3d3d3; position: absolute; top: 5px; right: 5px;"></table>
        </center>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
        <script>
            // Client configuration - must match server's settings
            var config = {
                framesPerSecond: 60,            // FPS to run the simulation at
                mapSize: {                      // Size of the map (must be the same as the canvas size)
                    x: 500,
                    y: 500
                },
                tankSpeed: 25,                  // Tank speed in pixels per second
                shellSpeed: 100,                // Shell speed in pixels per second
                serverIP: "localhost",          // Server's IP
                serverPort: "9042",             // Server's port
                apiPath: "/pyTanksAPI/viewer"   // API path on the server to connect to
            };
            
            // Globals
            var gameState = null;
            var gameStateUpdate = null;
            var canvas = null;
            var clientStatus = null;
            var scoreboard = null;
            
            // Setup and run the viewer
            $(function() {
                canvas = $("#canvas")[0].getContext("2d");
                clientStatus = $("#clientStatus");
                scoreboard = $("#scoreboard");
                
                // Connect to sever
                var socket = new WebSocket("ws://" + config.serverIP + ":" + config.serverPort + config.apiPath);
                
                // Finish setup on successful connect
                socket.onopen = function (event) {
                    clientStatus.html("Connected");
                    
                    // Start the doTick clock
                    var ticker = window.setInterval(function(){ doTick(); }, 1000 / config.framesPerSecond);
                
                    // Store any incoming gameState updates
                    socket.onmessage = function (event) {
                        gameStateUpdate = JSON.parse(event.data);
                    };
                    
                    // Handle a disconnect
                    socket.onclose = function (event) {
                        window.clearInterval(ticker);
                        clientStatus.html("Lost connection");
                    };
                };
            
                // Handle errors in connecting
                socket.onerror = function (event) {
                    clientStatus.html("Failed to connect");
                };
            });
            
            // Calculates and renders one frame
            function doTick() {
                // Return if no data from the server has arrived yet
                if (gameState == null && gameStateUpdate == null) {
                    return;
                }
                
                if (gameStateUpdate == null) {
                    // Extrapolate if there isn't an update from the server
                    var totalDistance = config.tankSpeed * (1 / config.framesPerSecond);
                    for (tank of gameState.tanks) {
                        if (tank.moving) {
                            tank.x += Math.cos(tank.heading) * totalDistance;
                            tank.y += Math.sin(tank.heading) * totalDistance;
                        }
                    }
                    
                    totalDistance = config.shellSpeed * (1 / config.framesPerSecond);
                    for (shell of gameState.shells) {
                        shell.x += Math.cos(shell.heading) * totalDistance;
                        shell.y += Math.sin(shell.heading) * totalDistance;
                    }
                } else {
                    // Apply the update from the server
                    gameState = gameStateUpdate;
                    gameStateUpdate = null;
                    
                    if (gameState.ongoingGame) {
                        clientStatus.html("Connected - Game in progress");
                    } else {
                        clientStatus.html("Connected - Waiting for players");
                    }
                    
                    var scoreHTML = "<tr><td></td><td>Tank</td><td>Kills this round</td><td>Rounds won</td></tr>";
                    for (tank of gameState.tanks) {
                        scoreHTML += "<tr><td>";
                        
                        if (tank.alive) {
                            scoreHTML += "A";
                        } else {
                            scoreHTML += "D";
                        }
                        
                        scoreHTML += "</td><td>" + tank.name + "</td><td>" + tank.kills + "</td><td>" + tank.wins + "</td></tr>";
                    }
                    if (scoreboard.html() != scoreHTML) {
                        scoreboard.html(scoreHTML);
                    }
                }
                
                // Render based on that game state
                canvas.clearRect(0, 0, config.mapSize.x, config.mapSize.y);
                
                if (gameState.ongoingGame) {
                    canvas.fillStyle = "Orange";
                    for (tank of gameState.tanks) {
                        if (!tank.alive) {
                            drawRotatedRect(tank.x - 5, tank.y - 5, 10, 10, tank.heading);
                        }
                    }
                    
                    canvas.fillStyle = "Red";
                    for (shell of gameState.shells) {
                        drawRotatedRect(shell.x - 1, shell.y - 1, 3, 3, shell.heading);
                    }
                    
                    canvas.fillStyle = "Black";
                    for (tank of gameState.tanks) {
                        if (tank.alive) {
                            drawRotatedRect(tank.x - 5, tank.y - 5, 10, 10, tank.heading);
                        }
                    }
                    
                    canvas.fillStyle = "Gray";
                    for (wall of gameState.walls) {
                        canvas.fillRect(wall.x - wall.width / 2, wall.y - wall.height / 2, wall.width, wall.height);
                    }
                }
            }
            
            // Draws a rotated rectangle with the current fill style
            function drawRotatedRect(x, y, width, height, heading) {
                canvas.save();
                canvas.translate(x + width / 2, y + height / 2);
                canvas.rotate(heading);
                // Note: after transforming [0,0] is visually [x,y] so the rect needs to be offset accordingly when drawn
                canvas.fillRect(-width / 2, -height / 2, width, height);
                canvas.restore();
            }
        </script>
    </body>
</html>